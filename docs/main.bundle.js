(()=>{"use strict";var e={33:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.camera=void 0,t.camera="\nRay cameraGetRay(vec3 lookFrom, vec3 lookAt, vec3 vUp, float vFov) {\n    float aspectRatio = u_resolution.x / u_resolution.y;\n    float theta = vFov * PI / 180.0;\n    float h = tan(theta / 2.0);\n    float viewportHeight = 2.0 * h;\n    float viewportWidth = aspectRatio * viewportHeight;\n    \n    vec3 w = normalize(lookFrom - lookAt);\n    vec3 u = normalize(cross(vUp, w));\n    vec3 v = cross(w, u);\n    \n    vec3 horizontal = u * viewportWidth;\n    vec3 vertical = v * viewportHeight;\n    vec3 lowerLeftCorner = lookFrom - (horizontal / 2.0) - (vertical / 2.0) - w;\n    \n    vec2 uv = gl_FragCoord.xy / (u_resolution - 1.0);\n    return rayInit(lookFrom, lowerLeftCorner + uv.x * horizontal + uv.y * vertical - lookFrom);\n}\n"},57:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.PreviewSection=void 0;const a=n(697);t.PreviewSection=class{constructor(){this.renderer=new a.Renderer(320,240),this.cameraYRotSlider=$('<input type="range" min="0.0" max="1.0" step="0.00001" value="0.0">').on("input",(()=>this.preview())),this.cameraXRotSlider=$('<input type="range" min="0.0" max="0.999" step="0.00001" value="0.3">').on("input",(()=>this.preview())),this.cameraZRotSlider=$('<input type="range" min="-1.0" max="1.0" step="0.00001" value="0.0">').on("input",(()=>this.preview())),this.cameraDistSlider=$('<input type="range" min="0.1" max="10.0" step="0.00001" value="5.0">').on("input",(()=>this.preview())),this.galaxyRadiusSlider=$('<input type="range" min="2.0" max="5.0" step="0.00001" value="3.0">').on("input",(()=>this.preview())),this.galaxyHeightSlider=$('<input type="range" min="0.1" max="1.0" step="0.00001" value="0.3">').on("input",(()=>this.preview())),this.armAlphaSlider=$('<input type="range" min="0.01" max="2.0" step="0.00001" value="0.3">').on("input",(()=>this.preview())),this.armWidthSlider=$('<input type="range" min="0.01" max="5.0" step="0.00001" value="2.5">').on("input",(()=>this.preview())),this.armsSlider=$('<input type="range" min="0.00" max="10.0" step="0.00001" value="2.0">').on("input",(()=>this.preview())),this.spiralStrengthSlider=$('<input type="range" min="-10.00" max="10.0" step="0.00001" value="3.4">').on("input",(()=>this.preview())),this.armDistortionSlider=$('<input type="range" min="0.00" max="1.0" step="0.00001" value="0.3">').on("input",(()=>this.preview())),this.stickRadiusSlider=$('<input type="range" min="0.00" max="3.0" step="0.00001" value="0.0">').on("input",(()=>this.preview())),this.element=$("<section>").append($("<h2>").text("【STEP.1】 各種設定を行ってください"),$('<div class="preview-container">').append($(this.renderer.webGlCanvas.canvas).on("click",(()=>{console.log(JSON.stringify(this.getRenderParams(0)))})),$('<div class="params">').append($("<div>").text("カメラ左右："),this.cameraYRotSlider,$("<div>").text("カメラ上下："),this.cameraXRotSlider,$("<div>").text("カメラ傾き："),this.cameraZRotSlider,$("<div>").text("カメラ距離："),this.cameraDistSlider,$("<div>").text("銀河の半径："),this.galaxyRadiusSlider,$("<div>").text("銀河の厚み："),this.galaxyHeightSlider,$("<div>").text("腕の濃さ："),this.armAlphaSlider,$("<div>").text("腕の幅："),this.armWidthSlider,$("<div>").text("腕の数："),this.armsSlider,$("<div>").text("腕の回転："),this.spiralStrengthSlider,$("<div>").text("腕の歪み："),this.armDistortionSlider,$("<div>").text("棒状銀河："),this.stickRadiusSlider))),this.preview()}getRenderParams(e){let t=0,n=0,a=0;switch(e){case 0:t=100,n=3,a=2;break;default:case 1:t=200,n=3,a=2;break;case 2:t=300,n=6,a=4;break;case 3:t=500,n=12,a=8}return{cameraYRot:-parseFloat(this.cameraYRotSlider.val()+"")*Math.PI*2,cameraXRot:-parseFloat(this.cameraXRotSlider.val()+"")*Math.PI/2,cameraZRot:parseFloat(this.cameraZRotSlider.val()+"")*Math.PI/2,cameraDist:parseFloat(this.cameraDistSlider.val()+""),galaxyRadius:parseFloat(this.galaxyRadiusSlider.val()+""),galaxyHeight:parseFloat(this.galaxyHeightSlider.val()+""),armAlpha:parseFloat(this.armAlphaSlider.val()+""),armWidth:parseFloat(this.armWidthSlider.val()+""),arms:parseFloat(this.armsSlider.val()+""),spiralStrength:parseFloat(this.spiralStrengthSlider.val()+""),armDistortion:parseFloat(this.armDistortionSlider.val()+""),stickRadius:parseFloat(this.stickRadiusSlider.val()+""),cloudMaxSteps:t,fbmMaxSteps:n,fbmMinSteps:a}}preview(){this.renderer.render(this.getRenderParams(0))}}},63:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.RenderSection=void 0;const a=n(697);t.RenderSection=class{constructor(e){this.renderer=new a.Renderer(1,1),this.widthInput=$('<input type="number" min="1" value="800">'),this.heightInput=$('<input type="number" min="1" value="600">'),this.resultDiv=$('<div class="render-result">'),this.qualitySelect=$("<select>").append($('<option value="0">').text("低"),$('<option value="1" selected>').text("中"),$('<option value="2">').text("高"),$('<option value="3">').text("最高")),this.element=$("<section>").append($("<h2>").text("【STEP.2】 問題無ければ[画像生成]ボタンを押してください"),$('<div class="render-contents">').append($('<div class="params">').append($("<div>").text("出力解像度："),$('<div class="resolution">').append(this.widthInput,$("<div>").text("×"),this.heightInput),$("<div>").text("品質："),this.qualitySelect),$("<button>").text("画像生成").on("click",(()=>e())),$("<ul>").append(["スマホでは品質や解像度を上げると正常に動作しない場合があります。なるべくハイスペックなPCでお試しください。","画像が生成されたら画像を右クリック（長押し）してコピーや保存を行ってください。"].map((e=>$("<li>").text(e)))),this.resultDiv))}render(e){const t=parseInt(this.qualitySelect.val()+""),n=e.getRenderParams(t),a=Math.max(Math.floor(parseInt(this.widthInput.val()+"")),1),r=Math.max(Math.floor(parseInt(this.heightInput.val()+"")),1);this.resultDiv.empty(),this.renderer.webGlCanvas.resize(a,r),this.renderer.render(n);const o=new Image;o.src=this.renderer.webGlCanvas.canvas.toDataURL("image/png"),this.resultDiv.append(o)}}},108:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.defines=void 0,t.defines="\nprecision highp float;\nprecision highp int;\n\nuniform vec2 u_resolution;\nuniform float u_cameraYRot;\nuniform float u_cameraXRot;\nuniform float u_cameraZRot;\nuniform float u_cameraDist;\nuniform float u_galaxyRadius;\nuniform float u_galaxyHeight;\nuniform float u_armAlpha;\nuniform float u_armWidth;\nuniform float u_arms;\nuniform float u_stickRadius;\nuniform float u_armDistortion;\nuniform float u_spiralStrength;\n\nuniform int u_cloudMaxSteps;\nuniform int u_fbmMaxSteps;\nuniform int u_fbmMinSteps;\n\nconst float PI = 3.14159265359;\n"},136:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ray=void 0,t.ray="\nstruct Ray {\n    // レイの原点\n    vec3 origin;\n    // レイの方向（単位ベクトル）\n    vec3 direction;\n};\n\n// レイ初期化\nRay rayInit(vec3 origin, vec3 direction) {\n    return Ray(origin, normalize(direction));\n}\n\n// レイの進行度tにおける座標を取得\nvec3 rayAt(Ray ray, float t) {\n    return ray.origin + t * ray.direction;\n}\n"},166:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.smoothMinMax=void 0,t.smoothMinMax="\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h); \n}\n"},308:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.buildFragmentShader=function(){return`${r.defines}\n${l.simplexNoise}\n${s.ray}\n${i.matrix}\n${c.smoothMinMax}\n${a.camera}\n${o.galaxy}\n\nvoid main() {\n    vec3 from = vec3(0.0, 0.0, u_cameraDist) * rotateX(u_cameraXRot) * rotateY(u_cameraYRot);\n    cameraOrigin = from;\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    \n    vec3 forward = normalize(lookAt - from);\n\n    // 基本の right と up ベクトル（ワールド基準）\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(forward, worldUp));\n    vec3 up = normalize(cross(right, forward));\n\n    // カメラの up をロール角で回転\n    mat2 roll = mat2(\n        cos(u_cameraZRot), -sin(u_cameraZRot),\n        sin(u_cameraZRot), cos(u_cameraZRot)\n    );\n\n    // ロールは right-up 平面上で回転なので 2D行列で適用\n    vec2 rolled = roll * vec2(dot(right, worldUp), dot(up, worldUp));\n    vec3 vUp = normalize(rolled.x * right + rolled.y * up);\n\n    Ray ray = cameraGetRay(cameraOrigin, lookAt, vUp, 90.0);\n\n    float brightness = 0.0;\n    float n = snoise(ray.direction * 100.0);\n    brightness = smoothstep(0.7, 1.0, n);\n    vec4 col = getGalaxy(ray);\n    if (brightness > 0.0 && col.a < 1.0) {\n        col = mix(vec4(blackBodyColor(0.1 + brightness * 0.3), brightness), col, col.a);\n    }\n\n    gl_FragColor = vec4(mix(vec3(0.0), col.rgb, col.a), 1.0);\n}\n`};const a=n(33),r=n(108),o=n(870),i=n(819),s=n(136),l=n(674),c=n(166)},453:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLCanvas=void 0,t.WebGLCanvas=class{constructor(e,t,n){this.fragmentShaderSource=n,this.canvas=$("<canvas>")[0],this.canvas.width=e,this.canvas.height=t;const a=this.canvas.getContext("webgl",{preserveDrawingBuffer:!0});if(!a)throw alert("WebGLの初期化に失敗"),"WebGLの初期化に失敗";this.gl=a,this.setupWebGL()}get isContextLost(){return this.gl.isContextLost()}setupWebGL(){const e=this.gl,t=this.createShader(e.VERTEX_SHADER,"\nattribute vec4 a_position;\nvoid main() {\n    gl_Position = a_position;\n}\n"),n=this.createShader(e.FRAGMENT_SHADER,this.fragmentShaderSource),a=e.createProgram();this.program=a,e.attachShader(a,t),e.attachShader(a,n),e.linkProgram(a),e.getProgramParameter(a,e.LINK_STATUS)||console.error("Program link error:",e.getProgramInfoLog(a)),e.useProgram(a);const r=new Float32Array([-1,-1,1,-1,-1,1,1,1]),o=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW);const i=e.getAttribLocation(a,"a_position");e.vertexAttribPointer(i,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(i),this.uResolutionLocation=e.getUniformLocation(a,"u_resolution"),e.uniform2f(this.uResolutionLocation,this.canvas.width,this.canvas.height)}getUniformLocation(e){return this.gl.getUniformLocation(this.program,e)}uniform1f(e,t){this.gl.uniform1f(e,t)}uniform1i(e,t){this.gl.uniform1i(e,t)}render(){const e=this.gl;e.clearColor(0,0,0,1),e.clear(e.COLOR_BUFFER_BIT),e.drawArrays(e.TRIANGLE_STRIP,0,4)}resize(e,t){this.canvas.width=e,this.canvas.height=t,this.gl.uniform2f(this.uResolutionLocation,e,t),this.gl.viewport(0,0,e,t)}createShader(e,t){const n=this.gl.createShader(e);if(!n)throw"shader can't created!";if(this.gl.shaderSource(n,t),this.gl.compileShader(n),!this.gl.getShaderParameter(n,this.gl.COMPILE_STATUS))throw console.log(t),`Shader compile error: ${this.gl.getShaderInfoLog(n)}`;return n}}},674:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.simplexNoise=void 0,t.simplexNoise="\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n"},697:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Renderer=void 0;const a=n(453),r=n(308);t.Renderer=class{constructor(e,t){this.uniform1fInfos=[{name:"u_cameraYRot",getValue:e=>e.cameraYRot},{name:"u_cameraXRot",getValue:e=>e.cameraXRot},{name:"u_cameraZRot",getValue:e=>e.cameraZRot},{name:"u_cameraDist",getValue:e=>e.cameraDist},{name:"u_galaxyRadius",getValue:e=>e.galaxyRadius},{name:"u_galaxyHeight",getValue:e=>e.galaxyHeight},{name:"u_armAlpha",getValue:e=>e.armAlpha},{name:"u_armWidth",getValue:e=>e.armWidth},{name:"u_arms",getValue:e=>e.arms},{name:"u_spiralStrength",getValue:e=>e.spiralStrength},{name:"u_armDistortion",getValue:e=>e.armDistortion},{name:"u_stickRadius",getValue:e=>e.stickRadius}],this.uniform1iInfos=[{name:"u_cloudMaxSteps",getValue:e=>e.cloudMaxSteps},{name:"u_fbmMaxSteps",getValue:e=>e.fbmMaxSteps},{name:"u_fbmMinSteps",getValue:e=>e.fbmMinSteps}],this.webGlCanvas=new a.WebGLCanvas(e,t,(0,r.buildFragmentShader)()),this.setupUniformLocations()}setupUniformLocations(){this.uniform1fInfos.forEach((e=>e.location=this.webGlCanvas.getUniformLocation(e.name))),this.uniform1iInfos.forEach((e=>e.location=this.webGlCanvas.getUniformLocation(e.name)))}render(e){this.webGlCanvas.isContextLost&&(this.webGlCanvas.setupWebGL(),this.setupUniformLocations()),this.uniform1fInfos.forEach((t=>this.webGlCanvas.uniform1f(t.location,t.getValue(e)))),this.uniform1iInfos.forEach((t=>this.webGlCanvas.uniform1i(t.location,t.getValue(e)))),this.webGlCanvas.render()}}},819:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.matrix=void 0,t.matrix="\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        c, -s, 0.0,\n        s,  c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n"},870:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.galaxy=void 0,t.galaxy="\nconst vec3 galaxyCenter = vec3(0.0, 0.0, 0.0);\nconst vec3 bulgeColor = vec3(255.0 / 255.0, 187.0 / 255.0, 100.0 / 255.0); \nconst float bulgeRadius = 0.5;\nconst float haloFalloff = 1.5;\nconst vec3 haloColor = vec3(1.0, 1.0, 1.0);\n\nvec3 cameraOrigin;\n\nfloat fbm(vec3 p, float scaleBase, float scalePow, float depthBase, float depthPow) {\n    \n    // 近いところは回数を増やしたい\n    float dist = distance(cameraOrigin, p);\n    int steps = int(mix(float(u_fbmMaxSteps), float(u_fbmMinSteps), clamp(dist / 20.0, 0.0, 1.0)));\n\n    float res = 0.0;\n    for (int i = 0; i < 50; i++) {\n        if (i >= steps) {\n            break;\n        }\n\n        float scale = scaleBase * pow(scalePow, float(i));\n        float depth = depthBase * pow(depthPow, float(i));\n        res += snoise(p * scale) * depth;\n    }\n    return res;\n}\n\n// 渦巻き共通処理\nfloat armDist(vec3 pos, float r) {\n    float angle = atan(pos.z, pos.x);\n    float r2 = u_stickRadius == 0.0 ? r : (smax(r - u_stickRadius, 0.0, 0.4));\n    float spiralAngle = mod(angle + r2 * u_spiralStrength, 2.0 * PI);\n    float armDist = abs(mod(spiralAngle * u_arms + PI, 2.0 * PI) - PI);\n    return armDist;\n}\n\n// 明るい星たち\nfloat getStarsDensity(vec3 worldPos) {\n    vec3 pos = worldPos;// - galaxyCenter;\n    \n    // 高さマスク（パッツン）\n    float heightMask = abs(pos.y) < (u_galaxyHeight * 0.5) ? 1.0 : 0.0;\n    if (heightMask < 0.01) {\n        return 0.0;\n    }\n\n    // 半径FBM(重い)\n    float r = length(pos.xz) + fbm(pos, 0.65, 4.0, 1.0, 0.6) * u_armDistortion;\n\n    // 半径マスク\n    float radiusMask = (1.0 - smoothstep(0.8, 1.0, r / u_galaxyRadius));\n    if (radiusMask < 0.01) {\n        return 0.0;\n    }\n\n    // 腕マスク\n    float armDist = armDist(pos, r);\n    float armMask = 0.5 + smoothstep(u_armWidth, 0.0, armDist) * 0.9;\n\n    return (snoise(pos * 100.0) * 0.5 + 0.5) * radiusMask * heightMask * armMask;\n}\n\n// ダスト・レーン\nfloat getDustsDensity(vec3 worldPos) {\n    vec3 pos = worldPos;// - galaxyCenter;\n\n    // 高さマスク（パッツン）\n    float heightMask = abs(pos.y) < (u_galaxyHeight * 0.5) ? 1.0 : 0.0;\n    if (heightMask < 0.01) {\n        return 0.0;\n    }\n\n    // 半径FBM(重い)\n    float r = length(pos.xz) + fbm(pos, 0.65, 6.0, 1.0, 0.3) * 0.5;\n\n    // 半径マスク\n    float radiusMask = smoothstep(0.5, 0.8, r / u_galaxyRadius) * (1.0 - smoothstep(0.8, 1.0, r / u_galaxyRadius));\n    if (radiusMask < 0.01) {\n        return 0.0;\n    }\n\n    // 腕マスク\n    float armDist = armDist(pos, r);\n    float armMask = smoothstep(0.8, 0.0, armDist) * 0.9;\n\n    return (snoise(pos * 30.0)) * radiusMask * heightMask * armMask * 6.0;\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float sphereRadius, out float tMin, out float tMax) {\n    vec3 L = rayOrigin - sphereCenter;\n    float a = dot(rayDir, rayDir); // 通常1\n    float b = 2.0 * dot(rayDir, L);\n    float c = dot(L, L) - sphereRadius * sphereRadius;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0) {\n        return false; // 交差しない\n    }\n\n    float sqrtDiscriminant = sqrt(discriminant);\n    float inv2a = 0.5 / a;\n\n    tMin = (-b - sqrtDiscriminant) * inv2a;\n    tMax = (-b + sqrtDiscriminant) * inv2a;\n\n    return true; // 交差あり\n}\n\n// from FabriceNeyret2 shader Black Body Spectrum plank [https://www.shadertoy.com/view/4tdGWM]\nvec3 blackBodyColor(float k) {\n    float T = (k*2.)*16000.;\n    vec3 c = vec3(1.,3.375,8.)/(exp((19e3*vec3(1.,1.5,2.)/T)) - 1.); // Planck law\n    return c / max(c.r,max(c.g,c.b));  // chrominance\n}\n\nvec4 getGalaxyComponentColor(vec3 pos) {\n    float distToCenter2 = length(vec3(pos.x, pos.y * 1.4, pos.z) - galaxyCenter);\n\n    // バルジ\n    float bulge = exp(-pow(distToCenter2 / bulgeRadius, 2.0)) * 1.5;\n\n    // ハロー\n    //float halo = exp(-distToCenter2 / haloFalloff) * 1.3;\n    float halo = exp(-pow(distToCenter2 / haloFalloff, 1.5)) * 1.5;\n\n    // ディスク（渦）\n    float stars = getStarsDensity(pos) * 1.5;\n    vec3 starsColor = blackBodyColor(clamp(0.1 + pow(stars, 2.0) * 0.4, 0.01, 1.0));\n\n    // ダスト（渦）\n    float dust = getDustsDensity(pos);\n\n    // 合成\n    vec3 color = bulgeColor * bulge + haloColor * halo + starsColor * stars;\n\n    color = mix(color, vec3(0.2275, 0.0863, 0.0863), clamp(dust, 0.0, 1.0));\n    float alpha = (bulge * 0.3 + halo * 0.09 + stars * u_armAlpha) * 10.0 + dust;\n    return vec4(color, alpha);\n}\n\nvec4 getGalaxy(Ray ray) {\n    float r2 = length(vec3(u_galaxyRadius + u_armDistortion, u_galaxyHeight * 0.5, 0));\n\n    float tMin, tMax;\n    if (!intersectSphere(ray.origin, ray.direction, galaxyCenter, r2, tMin, tMax)) {\n        return vec4(0.0);\n    }\n\n    tMin = max(tMin, 0.001);\n    tMax = max(tMax, 0.001);\n    \n    float stepSize = (tMax - tMin) / float(u_cloudMaxSteps);\n    vec3 p = rayAt(ray, tMin);\n    vec3 pStep = ray.direction * stepSize;\n    vec4 finalColor = vec4(0.0);\n    \n    for (int i = 0; i < 1000; i++) {\n        if (i >= u_cloudMaxSteps) {\n            break;\n        }\n \n        vec4 color = getGalaxyComponentColor(p);\n        color.a *= stepSize;\n        finalColor.rgb += (1.0 - finalColor.a) * color.a * color.rgb;\n        finalColor.a += (1.0 - finalColor.a) * color.a;\n\n        if (finalColor.a > 0.99) { \n            break;\n        }\n\n        p += pStep;\n    }\n\n    return vec4(finalColor.r, finalColor.g, finalColor.b, clamp(finalColor.a * 1.0, 0.0, 1.0));\n}\n"},948:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ReadmeSection=void 0,t.ReadmeSection=class{constructor(){this.element=$("<section>").append($("<h2>").text("【STEP.0】 お読みください"),$("<div>").append($("<ul>").append($("<li>").text("銀河のような画像を計算で生成します。"),$("<li>").text("生成された画像の著作権は利用者に帰属します。商用利用可能です（クレジット表記などは歓迎いたします）。"),$("<li>").html("WebGLを使用しています。NVIDIAの良いグラボが有ると快適に動作いたします。PC推奨。"),$("<li>").html('ソースコードはこちら：<a href="https://github.com/takabosoft/galaxy-gen" target="_blank">https://github.com/takabosoft/galaxy-gen</a>'))))}}}},t={};function n(a){var r=t[a];if(void 0!==r)return r.exports;var o=t[a]={exports:{}};return e[a](o,o.exports,n),o.exports}(()=>{const e=n(57),t=n(948),a=n(63);$((()=>new r));class r{constructor(){const n=new e.PreviewSection,r=new a.RenderSection((()=>r.render(n)));$(document.body).append($("<main>").append((new t.ReadmeSection).element,n.element,r.element),$("<div>").css({flex:"1 1 0"}),$("<footer>").html('銀河ジェネレーター Copyright (C) 2025 <a href="https://takabosoft.com/" target="_blank">Takabo Soft</a>'))}}})()})();